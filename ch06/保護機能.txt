■CPUが各命令語毎に行うチェック

・Limitチェック
・Typeチェック
・特権レベルチェック
・命令セットチェック


●Limitチェック
セグメントディスクリプタのLimitは、プログラムまたはプロセスがセグメント範囲外のメモリ位置をオフセットで指定できないようにする。
セグメントディスクリプタ内のGビットが0である場合、Limitを0～0xFFFFF(1MB)まで選択することができる。
Gビットが1の場合には、Limitを0xFFF(4KB)～0xFFFFFFFF(4GB)まで選択することができる。
セグメント領域で、有効Limitは全体セグメント領域の大きさから1バイトを引き算したものになる。
次のような場合にCPUは一般保護例外(#GP)を発生させる。

・オフセットが有効Limitより大きいバイト
・オフセットが有効Limit-1バイトより大きいワード
・オフセットが有効Limit-3バイトより大きいダブルワード
・オフセットが有効Limit-7バイトより大きいクアッドワード

Limitチェックは、暴走するコードや、無効なポインタ計算等のプログラミングのエラーを検出する。
Limitをチェックしなければ、このようなエラーによって他のセグメントにあるコードやデータがオーバライトされる危険が存在する。
CPUはセグメント領域のLimitチェックとともに、GDTやIDTのようなテーブル、そしてTSS領域の大きさもチェックする。
GDTとIDTの場合、GDTR、IDTRの6バイト(48ビット)中、2バイト(16ビット)のLimit値を使う。
TSSはTRレジスタ6バイト中、Limitを表す2バイトを使ってLimitをチェックする。

例）
セグメントディスクリプタのBase Addressに0x2004が入っているとする。
Limitには0xFFFFが入っている。
このセグメントの領域は物理アドレス0x2004～0x12003。
オフセットを指定するとき、0x7FFFにすれば、物理アドレスが0xA003。

もし、オフセットに0xFFFCを指定して、ダブルワードのデータを使って読み書きを試みたとすると、物理アドレス0x12000からスタートするが、ダウブルワード(4バイト)なので1バイトだけ溢れてしまう。
オフセットをこう指定してはならない。
オフセットに、0xFFFDを指定し、ワード値で操作しようとすると、0x12002からスタートするが、1バイトだけ溢れてしまうので、このオフセットの指定もできない。

●Typeチェック
セグメントディスクリプタにはSビットとTypeフィールドがある。
Sビットが0の場合、TypeフィールドがシステムTypeを表すことになる。
1の場合は、コードやデータセグメントのTypeという意味になる。

Sビットが0の時のタイプ一覧
0x0     予約されている
0x1     16ビット
0x2     LDT
0x3     Busy 16ビットTSS
0x4     16ビットのコールゲート
0x5     タスクゲート
0x6     16ビットの割り込みゲート
0x7     16ビットのトラップゲート
0x8     予約されている
0x9     32ビットTSS
0xA     予約されている
0xB     Busy32ビットのTSS
0xC     32ビットコールゲート
0xD     予約されている
0xE     32ビットの割り込みゲート
0xF     32ビットのトラップゲート

例えば、Pビットが1、DPLが00、Sが0で、32ビット割り込みゲートだった場合、ディスクリプタの一部分に0x8Eが入る。
32ビットのTSSだったら0x89、32ビットのTSSのBビットが1にセットされたとき0x8Bになることなどを憶えると、理解することが楽になる。
CPUはセグメントセレクタとセグメントディスクリプタを操作するとき、いろいろな時点でType情報を調査する。

例）
・セグメントセレクタがセグメントレジスタにロードされるとき
　CSにはコードセグメントのセレクタだけがロードできる。
    MOV AX, 0x08
    MOV CS, AX

・ディスクリプタが、セグメントレジスタにすでにロードされているセグメントに命令でアクセスするとき
　コードセグメント領域にはデータの書き込みが禁止される。
　読み取り専用データセグメントにデータの書き込みが禁止される。
　コードセグメント領域に読み取り可能フラグが設定されない状態では、この領域を読み取ることはできない。

・CALL/JMP命令のオペランドにセレクタがある場合、そのセレクタに対するディスクリプタのTypeフィールドを調査する
　例えば、TSSセレクタをオペランドにしたCALL・JMP命令では、そのセレクタに対するディスクリプタがTSS用か否かを自動的にチェックする。
　またはIRET命令が実行されたとき、現在実行中のタスクのNTビットが1にセットされていれば、これに対するTSS領域で"以前のタスクへのバックリンク"がTSS用であるかをチェックする。

・GDTの最初のディスクリプタであるNULLディスクリプタをCSやSSにロードしようとするとき、一般保護例外(#GP)が発生する。
　そして、DS、ES、FS、GSにロードは可能だが、ロードされたセレクタを使ってセグメント領域にアクセスしようとしても一般保護例外(#GP)が発生する。

■特権レベル
CPUの特権レベル：0～3の4つ
低いレベルのタスクが高いレベルのデータを参照しようとすれば、一般保護エラー(#GP)が発生する。
特権レベルを理解するためには、CPL、DPL、RPLの3つのレベルを理解しなければならない。

・CPL(Current Privilege Level)
現在実行されているタスクの特権レベル。
CPLは現在CS、SSセレクタレジスタの0、1番目ビットにある数。
プログラムが他の特権レベルのコードセグメントに制御が移行されれば、CPUはCPLを変更する。

・DPL(Description Privilege Level)
ディスクリプタに記載されたDPL値で2ビットに表現される。
ディスクリプタを通じたセグメント領域へのすべてのアクセスで、いつもCPLとDPLの関係がチェックされる。
例えば、現在低いレベルのCPLを持っているとして、高いレベルのデータセグメント領域へのアクセスを試みるとしたら、CSの0、1ビット(CPL)とセグメントディスクリプタにあるDPL値を比較するすることになる。
もちろん、こんな状況では、チェック後に不可能だという判断がされる。

・RPL(Requested Privilege Level)
特権レベル3のプロセスが、コールゲート(低い特権レベルで高い特権レベルのルーチンが実行できるようにする扉)を通じ特権レベル0にあるルーチンを実行しなければならない場合がある。
このとき一時的に特権レベル0に入るため、特権レベル0のデータ領域にもアクセスができる。
RPL値はこのような状況を防ぐために、OSカーネルが使用する値。
例えば、コールゲートに繋がっているルーチンに、このルーチンがどこから呼ばれたかを記録する方法がある。
特権レベル3のプロセスがコールゲートを通じてこのルーチンを呼ぶと、データセグメントセレクタに特権レベル3から呼ばれたということを示す。
RPLは、その単語が暗示するように、誰が要求したのかを表す値。
特権レベル3から呼ばれたというように表示しておくと、特権レベル0のデータには触れることができない。
しかし、特権レベル0から呼ばれると、OSカーネルと同じレベルで呼ばれたものであるので、特権レベル0のデータへのアクセスがが可能。
コールゲート以外の場合、たいていはRPLはCPLと同じだと見なす。


■コールゲート(Call Gate)
低い特権レベルのプログラムが実行の途中に、高い特権レベルに変更される手段の代表的なものに、割り込み、例外、コールゲートがある。
この中でハードウェア割り込みと例外では、低い特権レベルのプログラムが自分の意志とは関係なく特権レベルが変更される。
ソフトウェア割り込みとコールゲートは、低い特権レベルのプログラムが自分の意志によって高い特権レベルのルーチンを少しだけ使うためのもの。
コンピュータのメモリとハードディスクに入っている資料、そしてハードウェア入出力装置などはカーネルによって全体が管理されなければならない。
ユーザープログラムたちは決まったルーチンによって一部分だけをちょっとだけ使って、求めた結果を得る。
そして、すべてのものを管理するカーネルのルーチンは、ユーザーの要求にあたる結果を渡してくれなければならないし、ハードウェア資源を保護し、節約しながら使うように作られなければならない。

コールゲートも他のセグメントディスクリプタとともにGDTテーブルにディスクリプタとして含まれ、もう1つのセグメント定義と見なしてもいい。
低い特権レベルのプログラムが高い特権レベルのプログラムの一部分を使うための窓口セグメントになる。

コールゲートディスクリプタの形

カーネルルーチンのオフセット 15～0
ハンドラのコードセグメントセレクタ
P|DPL(2b)|0|1|1|0|0|仕様なし(3b)|引数の個数(5b)
カーネルルーチンのオフセット 31～16

引数の数の部分とType以外の部分は他のディスクリプタと似ている。
これをGDTに指定しておいて、ユーザープログラムはコードセレクタのときと同じくこのディスクリプタをセレクタで選択して、JMPやCALL命令を実行する。
オフセットはディスクリプタに指定されているため、どんな数字を使っても、ディスクリプタに指定されたオフセットのルーチンが実行される。


■コードとデータの特権レベル関係
特権レベル間のJMP命令は不可能。
CALL命令が特権レベル間の移動ができるようにしてくれている。
CALL命令はいつも低い特権レベルから高い特権レベルに対して行わなければならない。
RET命令は高い特権レベルから低い特権レベルに対して行わなければならない。
特権レベル0のコードが特権レベル3のコードを呼び出す理由はない。
もし特権レベル間のJMP命令を絶対使わなければならない場合、コールゲートを通じて行う。

特権レベル0で動作している間、CSセレクタの0、1ビットには00が入っている。
特権レベル3で動作する間のCSセレクタには0、1ビットに11(10進数で3)が入っていることになる。
特権レベル3でCALL命令を通じて特権レベル0のルーチンを呼び出すと、CSセレクタの0、1ビットに00が入る。
このときのCPLは0。
そしてルーチンが終わってRET命令で特権レベル3に戻ってくると、CSセレクタの0、1ビットに11(10進数で3)が再び入るようになる。
このときのCPLは3になる。
コードセグメント領域の特権レベルであるDPLと、その時のCPLの値はすべての状況で同じだと理解すればよい。
1つ例外があるとすれば、Conformingセグメントの場合。
これは特権レベル0のルーチンを呼び出してもCPLの値が3のままで実行され、RET命令で戻ってくる。
Conformingセグメントはコールゲートと関連がある。

特権レベル0ではどの特権レベルでもすべての特権レベルのデータセグメント領域にアクセスが可能。
しかし低い特権レベルのプロセスからは、高い特権レベルのデータのアクセスが禁止される。
接近を試みると、CPUでフォールトが発生する。
これで高い特権レベルのデータを保護することができる。
同じ特権レベルでは、もちろんデータのアクセスが許される。
低い特権レベルのプロセスが高い特権レベルのデータにアクセスする唯一の方法はCALL命令で高い特権レベルのルーチンを呼び出して、そのルーチンで決められている方法でデータを処理して、RET命令で戻ってくるという方法以外にはない。
そして、この方法でも、悪意を持っている低い特権レベルのプロセスのデータアクセスを防ぐために、カーネルでRPLを操作する必要がある。

■特権レベル変更時のスタックの変化
タスクの実行中、割り込みや例外が発生するとか、コールゲートを通るとき、特権レベルが変化する。
割り込みハンドラや例外処理ルーチン、コールゲートに指示されたカーネルルーチンはカーネルモードで実行されなければならないため、現在のタスクがユーザーモードで動作している途中で特権レベルを変えてハンドラに制御が移るようになる。
このようなスタックスイッチングは、高い特権レベルのルーチンがスタック空間の不足のためクラッシュされないようにするためと、低い特権レベルのルーチンがスタックを通じて高い特権レベルのルーチンに干渉できないようにするといった理由がある。
ハンドラやカーネルルーチンに入る前にスタックに戻ってくるアドレスなどを入れておいて、ハンドラやカーネルルーチンが終わって再びユーザーモードタスクに戻ってくるために、スタックに入れておいた値らを使う。

■CALL命令が実行されたときのスタック
ユーザータスクがコールゲートなどを使って、カーネルモードのルーチンを呼び出す場合、

・CPUはいったんこのタスクのTSS領域にあるSS0、ESP0の値を参照して、カーネルモードのスタックに、現在ユーザータスクが使っているSS、ESP、そして、ユーザータスクが現在進行中のルーチンのアドレスであるCS、EIPを順次PUSHする。
そしてCPUのSS、ESPレジスタにはSS0、ESP0の値をそれぞれ入れる。
・コールゲートに指定されたカーネルモードのルーチンアドレスにジャンプし、実行する。
・ルーチンを終えて戻るとき、RET命令が実行されれば、現在カーネルモードのスタックに保存されたSS、ESP、CS、EIPをPOPしてCPUのそれぞれのレジスタに復元し、ユーザーモードタスクに戻る。
このとき、先にCSを確認した後、現在カーネルモードより低い特権レベルならSSとESPをPOPする。


カーネルモードのルーチンが実行される前のカーネルモードスタックの姿
┌───────┐
│EIP    │
├──┬────┤
│CS│    │
├──┴────┤
│ESP    │
├──┬────┤
│SS│    │
└──┴────┘
呼び出し文に引数がある場合には、スタックの形が少し違う。
例えば、引数としてparameter1、parameter2の2つがある場合、呼ぶ方はユーザーレベルにあるルーチンで、呼ばれる方はカーネルレベルにあるルーチン。
ユーザーレベル(特権レベル3)のSS、ESPのアドレスに引数たちをPUSHとコールゲートを通じてカーネルレベル(特権レベル0)ルーチンに入っても、カーネルレベルのルーチンではスタックのアドレスがSS0、ESP0に変更されてスタックが他のアドレスを参照することになる。
POPしても前にユーザーレベルで入れた引数は出ないで他の値が出るようになる。
このような問題を解決するために、コールゲートのディスクリプタに'引数の数'部分が存在する。
これに、コールゲートを通じるカーネルルーチンで使う引数の数をあらかじめ記入しておく。
parameter1、parameter2の2つなら2を記入する。
あらかじめ指定しておくことなので、引数の数はここに記入しておいた数を守らなければならない。

■割り込み例外が発生した時のスタック
EFLAGSが追加されたことさえ除けば、コールゲートの場合と似ている。
先にカーネルモード(特権レベル0)で割り込みが発生したときには、スタック変更が起きない。特権レベル0では、システムをそこまで保護する必要がない。
なので、特権レベル0で使っていたSS、ESPそのままの値を使って、スタックにEFLAGS、CS、EIPをPUSHする。
ユーザーレベルタスクの動作の中に割り込みや例外が発生すれば、このユーザーレベルタスクのTSS領域でSS0、ESP0をCPUのSS、ESPレジスタにコピーする。
これでカーネルモードのスタックを使うようになる。
このカーネルモードスタックにコールゲートの場合と同じくユーザーモードのタスクが使っていたSS、ESP、CS、EIPなどのレジスタ値をPUSHして保存する。
その後、カーネルモードにある割り込みハンドラルーチンにジャンプして、割り込み処理が終わるとIRETを使って、前に割り込みが発生したユーザーモードに戻ってくる。
このとき、スタックにある値たちをPOPしてCPUのそれぞれのレジスタにまた復元する。
